"""Pollard's rho algorithm for integer factorization with cycle detection.

This module implements Pollard's rho algorithm using Floyd's cycle-finding
algorithm to efficiently factor composite integers.
"""

import logging
import math
import random
import sys
from typing import Dict, List, Optional, Tuple

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


class PollardRho:
    """Pollard's rho algorithm for integer factorization.

    Uses Floyd's cycle-finding algorithm to detect cycles in a sequence
    generated by a polynomial function, enabling efficient factorization.
    """

    def __init__(self) -> None:
        """Initialize Pollard's rho factorizer."""
        pass

    def _gcd(self, a: int, b: int) -> int:
        """Compute greatest common divisor using Euclidean algorithm.

        Args:
            a: First number.
            b: Second number.

        Returns:
            GCD of a and b.
        """
        while b:
            a, b = b, a % b
        return abs(a)

    def _polynomial(self, x: int, c: int, n: int) -> int:
        """Polynomial function f(x) = (x² + c) mod n.

        Args:
            x: Input value.
            c: Constant term.
            n: Modulus.

        Returns:
            (x² + c) mod n.
        """
        return ((x * x) % n + c) % n

    def _pollard_rho_single(
        self, n: int, c: int = 1, max_iterations: int = 10000
    ) -> Optional[int]:
        """Find a single factor of n using Pollard's rho algorithm.

        Uses Floyd's cycle-finding algorithm (tortoise and hare).

        Args:
            n: Number to factor.
            c: Constant for polynomial function. Default: 1.
            max_iterations: Maximum number of iterations. Default: 10000.

        Returns:
            A non-trivial factor of n, or None if not found.
        """
        if n % 2 == 0:
            return 2

        if n == 1:
            return None

        x = random.randint(2, n - 1)
        y = x
        d = 1

        iterations = 0
        while d == 1 and iterations < max_iterations:
            x = self._polynomial(x, c, n)
            y = self._polynomial(self._polynomial(y, c, n), c, n)
            d = self._gcd(abs(x - y), n)
            iterations += 1

        if d == n:
            return None

        return d if d > 1 else None

    def find_factor(
        self, n: int, max_attempts: int = 10, max_iterations: int = 10000
    ) -> Optional[int]:
        """Find a non-trivial factor of n.

        Tries multiple values of c if the first attempt fails.

        Args:
            n: Number to factor.
            max_attempts: Maximum number of attempts with different c values.
            max_iterations: Maximum iterations per attempt.

        Returns:
            A non-trivial factor of n, or None if not found.

        Raises:
            ValueError: If n < 2.
        """
        if n < 2:
            raise ValueError("n must be >= 2")

        if n == 2:
            return None

        if self._is_prime_simple(n):
            return None

        for attempt in range(max_attempts):
            c = random.randint(1, n - 1) if attempt > 0 else 1
            factor = self._pollard_rho_single(n, c, max_iterations)
            if factor is not None:
                return factor

        return None

    def _is_prime_simple(self, n: int) -> bool:
        """Simple primality test for small numbers.

        Args:
            n: Number to test.

        Returns:
            True if n is prime, False otherwise.
        """
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False

        i = 3
        while i * i <= n:
            if n % i == 0:
                return False
            i += 2

        return True

    def factorize(self, n: int, max_attempts: int = 10) -> Dict[int, int]:
        """Factorize n completely into prime factors with multiplicities.

        Args:
            n: Number to factorize.
            max_attempts: Maximum attempts per factor search.

        Returns:
            Dictionary mapping prime factors to their multiplicities.

        Raises:
            ValueError: If n < 2.
        """
        if n < 2:
            raise ValueError("n must be >= 2")

        factors: Dict[int, int] = {}

        if n == 1:
            return factors

        remaining = n

        while remaining > 1:
            if self._is_prime_simple(remaining):
                factors[remaining] = factors.get(remaining, 0) + 1
                break

            factor = self.find_factor(remaining, max_attempts=max_attempts)

            if factor is None:
                factors[remaining] = factors.get(remaining, 0) + 1
                break

            remaining //= factor
            factors[factor] = factors.get(factor, 0) + 1

        return factors

    def factorize_list(self, n: int, max_attempts: int = 10) -> List[int]:
        """Factorize n into a list of prime factors (with multiplicities).

        Args:
            n: Number to factorize.
            max_attempts: Maximum attempts per factor search.

        Returns:
            List of prime factors (may contain duplicates).

        Raises:
            ValueError: If n < 2.
        """
        factors_dict = self.factorize(n, max_attempts=max_attempts)
        factors_list: List[int] = []

        for factor, multiplicity in factors_dict.items():
            factors_list.extend([factor] * multiplicity)

        return sorted(factors_list)

    def get_all_factors(self, n: int, max_attempts: int = 10) -> List[int]:
        """Get all divisors of n.

        Args:
            n: Number to get divisors for.
            max_attempts: Maximum attempts per factor search.

        Returns:
            List of all divisors of n (sorted).

        Raises:
            ValueError: If n < 1.
        """
        if n < 1:
            raise ValueError("n must be >= 1")

        if n == 1:
            return [1]

        factors_dict = self.factorize(n, max_attempts=max_attempts)
        divisors = [1]

        for factor, multiplicity in factors_dict.items():
            new_divisors = []
            for power in range(1, multiplicity + 1):
                factor_power = factor ** power
                for d in divisors:
                    new_divisors.append(d * factor_power)
            divisors.extend(new_divisors)

        return sorted(set(divisors))

    def is_prime(self, n: int, max_attempts: int = 10) -> bool:
        """Check if n is prime using factorization.

        Args:
            n: Number to test.
            max_attempts: Maximum attempts per factor search.

        Returns:
            True if n is prime, False otherwise.

        Raises:
            ValueError: If n < 2.
        """
        if n < 2:
            raise ValueError("n must be >= 2")

        if n == 2:
            return True

        if n % 2 == 0:
            return False

        factor = self.find_factor(n, max_attempts=max_attempts)
        return factor is None

    def prime_factors(self, n: int, max_attempts: int = 10) -> List[int]:
        """Get distinct prime factors of n.

        Args:
            n: Number to factorize.
            max_attempts: Maximum attempts per factor search.

        Returns:
            List of distinct prime factors (sorted).

        Raises:
            ValueError: If n < 2.
        """
        factors_dict = self.factorize(n, max_attempts=max_attempts)
        return sorted(factors_dict.keys())

    def factorization_string(self, n: int, max_attempts: int = 10) -> str:
        """Get string representation of factorization.

        Args:
            n: Number to factorize.
            max_attempts: Maximum attempts per factor search.

        Returns:
            String representation like "2^2 * 3 * 5".

        Raises:
            ValueError: If n < 2.
        """
        factors_dict = self.factorize(n, max_attempts=max_attempts)

        if not factors_dict:
            return "1"

        parts = []
        for factor in sorted(factors_dict.keys()):
            multiplicity = factors_dict[factor]
            if multiplicity == 1:
                parts.append(str(factor))
            else:
                parts.append(f"{factor}^{multiplicity}")

        return " * ".join(parts)


def main() -> None:
    """Main function to run the Pollard's rho CLI interface."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Pollard's rho algorithm for integer factorization"
    )
    parser.add_argument(
        "number",
        type=int,
        nargs="?",
        help="Number to factorize",
    )
    parser.add_argument(
        "--factorize",
        type=int,
        help="Number to factorize completely",
    )
    parser.add_argument(
        "--find-factor",
        type=int,
        help="Find a single factor of the number",
    )
    parser.add_argument(
        "--is-prime",
        type=int,
        help="Check if number is prime",
    )
    parser.add_argument(
        "--all-factors",
        type=int,
        help="Get all divisors of the number",
    )
    parser.add_argument(
        "--prime-factors",
        type=int,
        help="Get distinct prime factors",
    )
    parser.add_argument(
        "--max-attempts",
        type=int,
        default=10,
        help="Maximum attempts per factor search (default: 10)",
    )

    args = parser.parse_args()

    try:
        pr = PollardRho()

        if args.factorize is not None:
            n = args.factorize
            factors_dict = pr.factorize(n, max_attempts=args.max_attempts)
            factors_list = pr.factorize_list(n, max_attempts=args.max_attempts)
            factorization_str = pr.factorization_string(
                n, max_attempts=args.max_attempts
            )

            print(f"Factorization of {n}:")
            print(f"  Prime factors: {factors_list}")
            print(f"  Factorization: {factorization_str}")
            print(f"  Factors with multiplicities: {factors_dict}")

        elif args.find_factor is not None:
            n = args.find_factor
            factor = pr.find_factor(n, max_attempts=args.max_attempts)
            if factor:
                print(f"A factor of {n}: {factor}")
                print(f"Other factor: {n // factor}")
            else:
                print(f"{n} appears to be prime (no non-trivial factor found)")

        elif args.is_prime is not None:
            n = args.is_prime
            is_prime = pr.is_prime(n, max_attempts=args.max_attempts)
            if is_prime:
                print(f"{n} is prime")
            else:
                print(f"{n} is composite")

        elif args.all_factors is not None:
            n = args.all_factors
            divisors = pr.get_all_factors(n, max_attempts=args.max_attempts)
            print(f"All divisors of {n}: {divisors}")
            print(f"Total number of divisors: {len(divisors)}")

        elif args.prime_factors is not None:
            n = args.prime_factors
            prime_factors = pr.prime_factors(n, max_attempts=args.max_attempts)
            print(f"Distinct prime factors of {n}: {prime_factors}")

        elif args.number is not None:
            n = args.number
            factors_dict = pr.factorize(n, max_attempts=args.max_attempts)
            factors_list = pr.factorize_list(n, max_attempts=args.max_attempts)
            factorization_str = pr.factorization_string(
                n, max_attempts=args.max_attempts
            )

            print(f"Factorization of {n}:")
            print(f"  Prime factors: {factors_list}")
            print(f"  Factorization: {factorization_str}")
            print(f"  Factors with multiplicities: {factors_dict}")

        else:
            print("Pollard's Rho Factorization Algorithm")
            print("Use --help to see available options")
            print("\nExamples:")
            print("  python src/main.py 100")
            print("  python src/main.py --factorize 100")
            print("  python src/main.py --find-factor 100")
            print("  python src/main.py --is-prime 97")

    except Exception as e:
        logger.error(f"Error: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main()
