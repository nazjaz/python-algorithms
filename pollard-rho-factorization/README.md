# Pollard's Rho Factorization Algorithm

A Python implementation of Pollard's rho algorithm for integer factorization with Floyd's cycle detection.

## Project Title and Description

This project implements Pollard's rho algorithm, a probabilistic algorithm for finding non-trivial factors of composite integers. The algorithm uses Floyd's cycle-finding algorithm (tortoise and hare) to detect cycles in a sequence generated by a polynomial function, enabling efficient factorization of large composite numbers.

Pollard's rho is particularly useful for factoring numbers that have small factors, making it faster than trial division for many composite numbers. It's widely used in number theory, cryptography, and computational mathematics.

**Target Audience**: Developers working with number theory, cryptography, competitive programming, and anyone needing efficient integer factorization.

## Features

- Pollard's rho algorithm with Floyd's cycle detection
- Complete factorization into prime factors with multiplicities
- Find single non-trivial factors
- Get all divisors of a number
- Distinct prime factors extraction
- Primality testing using factorization
- Factorization string representation
- Command-line interface for interactive use
- Comprehensive test suite

## Prerequisites

- Python 3.8 or higher
- pip (Python package manager)

No external dependencies are required. The implementation uses only Python standard library.

## Installation

### Step 1: Clone or Navigate to Project Directory

```bash
cd /Users/nasihjaseem/projects/github/python-algorithms/pollard-rho-factorization
```

### Step 2: Create Virtual Environment (Recommended)

```bash
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

### Step 3: Install Dependencies

```bash
pip install -r requirements.txt
```

Note: This project has no external dependencies for core functionality, but pytest is included for testing.

## Configuration

This project does not require configuration files or environment variables. All functionality is available through the command-line interface or by importing the classes directly.

### Algorithm Parameters

- **Polynomial function**: f(x) = (x² + c) mod n, where c is a constant (default: 1)
- **Max attempts**: Number of attempts with different c values (default: 10)
- **Max iterations**: Maximum iterations per attempt (default: 10000)

## Usage

### Command-Line Interface

#### Complete Factorization

Factorize a number completely:

```bash
python src/main.py 100
```

Output:
```
Factorization of 100:
  Prime factors: [2, 2, 5, 5]
  Factorization: 2^2 * 5^2
  Factors with multiplicities: {2: 2, 5: 2}
```

#### Find a Single Factor

Find one non-trivial factor:

```bash
python src/main.py --find-factor 100
```

Output:
```
A factor of 100: 2
Other factor: 50
```

#### Check Primality

Check if a number is prime:

```bash
python src/main.py --is-prime 97
```

Output:
```
97 is prime
```

#### Get All Divisors

Get all divisors of a number:

```bash
python src/main.py --all-factors 100
```

Output:
```
All divisors of 100: [1, 2, 4, 5, 10, 20, 25, 50, 100]
Total number of divisors: 9
```

#### Get Distinct Prime Factors

Get distinct prime factors:

```bash
python src/main.py --prime-factors 100
```

Output:
```
Distinct prime factors of 100: [2, 5]
```

#### Custom Max Attempts

Increase max attempts for difficult factorizations:

```bash
python src/main.py --factorize 1001 --max-attempts 20
```

### Programmatic Usage

```python
from src.main import PollardRho

# Create PollardRho instance
pr = PollardRho()

# Complete factorization
factors = pr.factorize(100)
print(f"Factors: {factors}")  # {2: 2, 5: 2}

# Find a single factor
factor = pr.find_factor(100)
print(f"A factor: {factor}")  # 2

# Get all divisors
divisors = pr.get_all_factors(100)
print(f"Divisors: {divisors}")

# Check primality
is_prime = pr.is_prime(97)
print(f"Is prime: {is_prime}")

# Get distinct prime factors
prime_factors = pr.prime_factors(100)
print(f"Prime factors: {prime_factors}")  # [2, 5]

# Factorization string
fact_str = pr.factorization_string(100)
print(f"Factorization: {fact_str}")  # "2^2 * 5^2"
```

### Common Use Cases

1. **Factorize a number**
   ```bash
   python src/main.py 100
   ```

2. **Find a factor**
   ```bash
   python src/main.py --find-factor 1001
   ```

3. **Check if prime**
   ```bash
   python src/main.py --is-prime 97
   ```

4. **Get all divisors**
   ```bash
   python src/main.py --all-factors 100
   ```

## Project Structure

```
pollard-rho-factorization/
├── README.md                 # Project documentation
├── requirements.txt          # Python dependencies
├── .gitignore               # Git ignore patterns
├── src/
│   └── main.py              # Main Pollard's rho implementation and CLI
├── tests/
│   └── test_main.py         # Comprehensive test suite
├── docs/
│   └── API.md               # API documentation
└── logs/
    └── .gitkeep             # Placeholder for log directory
```

### File Descriptions

- **src/main.py**: Contains the `PollardRho` class with all core functionality for factorization, factor finding, and divisor computation.
- **tests/test_main.py**: Comprehensive test suite covering all functionality including edge cases and various number sizes.
- **docs/API.md**: Detailed API documentation for all classes and methods.
- **logs/**: Directory for log files (if logging to files is enabled).

## Testing

### Run All Tests

```bash
pytest tests/
```

### Run Tests with Coverage

```bash
pytest tests/ --cov=src --cov-report=html
```

### Run Specific Test

```bash
pytest tests/test_main.py::TestPollardRho::test_factorize_small_number
```

### Test Coverage

The test suite aims for comprehensive coverage including:
- Factorization of various numbers
- Factor finding
- Primality testing
- Divisor computation
- Edge cases (primes, perfect squares, powers)
- Consistency checks

## Troubleshooting

### Common Issues

**Issue**: `ModuleNotFoundError: No module named 'src'`

**Solution**: Ensure you're running commands from the project root directory, or add the project root to your Python path:
```bash
export PYTHONPATH="${PYTHONPATH}:/path/to/pollard-rho-factorization"
```

**Issue**: Tests fail with import errors

**Solution**: Make sure you've installed pytest:
```bash
pip install pytest pytest-cov
```

**Issue**: Factorization fails or returns None

**Solution**: 
- Increase `max_attempts` parameter (try 20 or more)
- The algorithm works best for numbers with small factors
- Very large primes may require many attempts
- Some numbers may be difficult to factor with this method

**Issue**: Algorithm is slow for large numbers

**Solution**: Pollard's rho is probabilistic and may require many iterations. For very large numbers, consider:
- Increasing max_attempts
- Using other factorization methods for very large numbers
- The algorithm is most efficient when numbers have small factors

### Error Messages

- **"n must be >= 2"**: The number to factorize must be at least 2.
- **"n must be >= 1"**: The number for divisor computation must be at least 1.

## Contributing

### Development Setup

1. Fork the repository
2. Create a virtual environment
3. Install development dependencies:
   ```bash
   pip install pytest pytest-cov
   ```
4. Create a feature branch: `git checkout -b feature/your-feature-name`

### Code Style Guidelines

- Follow PEP 8 strictly
- Maximum line length: 88 characters
- Use type hints for all functions
- Write docstrings for all public functions and classes
- Run tests before committing

### Pull Request Process

1. Ensure all tests pass
2. Update documentation if needed
3. Write clear commit messages following conventional commit format
4. Submit pull request with description of changes

## Algorithm Details

### Pollard's Rho Algorithm

The algorithm works by:

1. **Polynomial function**: Uses f(x) = (x² + c) mod n to generate a sequence
2. **Cycle detection**: Uses Floyd's algorithm (tortoise and hare) to detect cycles
3. **Factor finding**: When a cycle is detected, computes GCD(|x - y|, n) to find a factor
4. **Recursive factorization**: Recursively factors found factors until all are prime

### Floyd's Cycle Detection

Also known as the "tortoise and hare" algorithm:
- Tortoise moves one step: x = f(x)
- Hare moves two steps: y = f(f(y))
- When x == y, a cycle is detected
- The GCD of |x - y| and n often reveals a factor

### Time Complexity

- **Expected time**: O(√p) where p is the smallest prime factor
- **Worst case**: O(n) if n is prime
- **Space complexity**: O(1) - only stores a few variables

### Advantages

- Much faster than trial division for numbers with small factors
- Probabilistic but very effective in practice
- Memory efficient (constant space)
- Works well for semi-primes (product of two primes)

### Limitations

- May fail for numbers that are prime or have only large factors
- Performance depends on the smallest prime factor
- May require multiple attempts with different constants

## Mathematical Background

### The Algorithm

Given a composite number n:

1. Choose a polynomial f(x) = (x² + c) mod n
2. Start with random x₀
3. Generate sequence: xᵢ₊₁ = f(xᵢ)
4. Use Floyd's algorithm to find cycle
5. When cycle detected, compute d = GCD(|x - y|, n)
6. If 1 < d < n, then d is a factor

### Why It Works

The sequence xᵢ will eventually cycle (by pigeonhole principle). When we find xᵢ = xⱼ with i ≠ j, we have:
- xᵢ ≡ xⱼ (mod p) for some factor p
- But xᵢ ≢ xⱼ (mod n) in general
- So GCD(|xᵢ - xⱼ|, n) reveals the factor p

### Polynomial Choice

The polynomial f(x) = (x² + c) mod n is commonly used because:
- It's simple and fast to compute
- It produces good pseudorandom sequences
- Different values of c help if one fails

## Performance Considerations

- Best performance when smallest factor is small
- Worst performance when number is prime
- Multiple attempts with different c values improve success rate
- For very large numbers, may need to combine with other methods

## License

This project is provided as-is for educational and practical use. Please refer to the LICENSE file in the parent directory for license information.
